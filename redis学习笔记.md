#### Redis简介

redis是一个内存数据库。它以键值对的形式存储数据、可以将键值对持久化到硬盘、可以使用复制特性来扩展读性能、可以使用客户端分片来扩展写性能

#### Redis数据结构

| 结构类型     | 存储的值                                                     | 读写能力                                                     |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| string字符串 | 字符串、整数或浮点数                                         | 对字符串或其中一部分进行操作；对整数和浮点数进行自增或自减操作 |
| list列表     | 一个链表，链表上的每个节点都包含了一个字符串                 | 从链表的两端推入或弹出元素；根据偏移量对链表进行修剪；读取单个或多个元素；根据值查找或移除元素 |
| set集合      | 无序且不重复的集合                                           | 添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素 |
| hash散列     | 包含键值对的无序散列表                                       | 添加、获取、移除单个键值对；获取所有键值对                   |
| zset有序列表 | 字符串成员与浮点数分值之间的有序映射，元素的排列顺序由分值的大小决定 | 添加、获取、删除单个元素；根据分值范围或者成员来获取元素     |

##### 字符串

一个由字节组成的序列

###### 字符串命令

GET：获取给定键的值。给定键不存在，返回nil

SET：设置给定键的值。执行成功返回OK

DEL：删除给定键的值。返回被成功删除的数量

##### 列表

由多个字符串值组成的有序序列

###### 列表命令

RPUSH：将给定值推入列表的右端

LRANGE：获取列表在给定范围上的所有值

LINDEX：获取列表在给定位置上的元素

LPOP：从列表的左端弹出一个值，并返回被弹出的值

##### 集合

###### 集合命令

SADD：将给定元素添加到集合

SMEMBERS：返回集合包含的所有元素

SISMEMBER：检查给定元素是否存在于集合中

SREM：如果给定的元素存在于集合中，那么移除这个元素

#### 散列

###### 散列命令

HSET：关联给定键值对

HGET：获取给定键的值

HGETALL：获取所有的键值对

HDEL：如果给定键存在于散列中，那么移除这个键

##### 有序集合

###### 有序集合命令

ZADD：将一个带有给定分值的成员添加到有序集合里面

ZRANGE：获取指定范围内的元素

ZRANGEBYSCORE：获取给定分值范围内的所有元素

ZREM：如果给定成员存在于集合中，则移除

#### 发布与订阅

订阅者负责订阅频道，发送者负责向频道发送二进制字符串消息

| 命令         | 用例和描述                                                   |
| ------------ | ------------------------------------------------------------ |
| subscribe    | subscribe channel [channel...] 订阅给定的一个或多个频道      |
| unsubscribe  | unsubscribe [channel[channel]] 退订给定的一个或多个频道，如果执行时没有指定频道，那么退订所有频道 |
| publish      | publish channel message 向给定频道发送消息                   |
| psubscribe   | psubscribe pattern [pattern..]订阅与给定模式相匹配的所有频道 |
| punsubscribe | punsubscribe [pattern [pattern]] 退订给定的模式，如果执行时没有给定任何模式，那么退订所有模式 |

#### 其他命令

- 排序sort

  sort source-key [by pattern] [limit offset count] [get pattern] [ASC|DESC] [alpha] [ store dest-key] 根据给定的选项，对输入列表、集合或者有序集合进行排序，然后返回或者存储排序的结果

#### Redis事务

Redis的基本事务需要用到multi命令和exec命令，这种事务可以让一个客户端在不被其他客户端打断的情况下执行多个命令

#### Redis持久化

redis提供了两种持久化方式来将数据存储到硬盘里面。一种方法叫快照，它可以将存在于某一时刻的所有数据都写入硬盘中。另一种方法叫做只追加文件，它会在执行写命令时，将被执行的写命令复制到硬盘里面。这两种持久化方法既可以同时使用，也可以单独使用，甚至在某些情况下都不使用

##### 快照持久化

通过创建快照来获取存储在内存里面的数据在某个时间点上的副本

创建快照的办法：

1. 客户端向redis发送BGSAVE命令，调用fork来创建子进程，由子进程负责将快照写入硬盘
2. 客户端向redis发送SAVE命令，接到SAVE命令的redis服务器在快照创建完毕之前将不再响应任何其他命令
3. 设置save配置选项，比如save 60 10000，从redis最近一次创建快照之后进行计算，“当60秒内有10000次写入“这个条件满足，redis就会自动触发BGSAVE命令
4. 执行SHUTDOWN命令或收到TERM信号时，会执行一个SAVE命令，阻塞所有客户端，不再执行客户端发送的任何命令，并在save命令执行完毕之后关闭服务器
5. 当一个服务器连接另一个服务器，并向对方发送SYNC命令来开始一次复制操作的时候，如果主服务器没有在执行BGSAVE操纵，或者主服务并非刚刚执行完BGSAVE操作，那么主服务器就会执行BGSAVE

##### AOF持久化

将被执行的写命令写到AOF文件的末尾

appendfsync选项及同步频率：

| 选项     | 同步频率                                       |
| -------- | ---------------------------------------------- |
| always   | 每个redis写命令都要同步写入硬盘                |
| everysec | 每秒执行一次同步，显示地将多个写命令同步到硬盘 |
| no       | 让操作系统来决定应该何时进行同步               |

重写/压缩AOF文件：为了解决AOF文件体积不断增大的问题，用户可以向redis发送BGREWRITEAOF命令，这个命令会通过移除AOF文件中的冗余命令来重写AOF文件

#### 复制

主从复制的过程：

| 步骤 | 主服务器操作                                                 | 从服务器操作                                                 |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | 等待命令                                                     | 连接主服务器，发送SYNC命令                                   |
| 2    | 开始执行BGSAVE，并使用缓冲区记录BGSAVE之后执行的所有写命令   | 根据配置来决定继续使用现有的数据来处理客户端的命令请求，还是向发送请求的客户端返回错误 |
| 3    | BGSAVE执行完毕，向从服务器发送快照文件，并在发送期间继续使用缓冲区记录被执行的写命令 | 丢弃所有旧数据，开始载入主服务器发来的快照文件               |
| 4    | 快照文件发送完毕，开始向从服务器发送缓冲区的写命令           | 完成对快照文件的解释操作，像往常一样开始接受命令请求         |
| 5    | 缓冲区存储的写命令发送完毕；从现在开始，每执行一个写命令，就像从服务器发送相同的写命令 | 执行主服务器发来的所有存储在缓冲区里面的写命令；并从现在开始，接收并执行主服务器传来的每个写命令 |

#### 缓存淘汰策略

- LRU

  LRU (Least recently used) 最近最少使用，算法根据数据的历史访问记录来进行淘汰数据，其核心思想 是“如果数据最近被访问过，那么将来被访问的几率也更高”

  volatile-lru 从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰 

  allkeys-lru从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰

- LFU

  LFU (Least frequently used) 最不经常使用，如果一个数据在最近一段时间内使用次数很少，那么在将 来一段时间内被使用的可能性也很小

  volatile-lfu、allkeys-lfu

- random

  随机

  volatile-random从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰

   allkeys-random从数据集（server.db[i].dict）中任意选择数据淘汰

- ttl

  time to live生存时间，从过期时间的表中随机挑选几个键值对，取出其中 ttl 最小的键值对淘汰

  volatile-ttl 从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
  redis 数据集数据结构中保存了键值对过期时间的表，即 redisDb.expires

- noenviction

  禁止驱逐数据，不删除 默认  

缓存淘汰策略的选择：

- allkeys-lru ： 在不确定时一般采用策略
- volatile-lru ： 比allkeys-lru性能差  存  : 过期时间 
- allkeys-random ： 希望请求符合平均分布(每个元素以相同的概率被访问) 
- 自己控制：volatile-ttl  缓存穿透 

#### 缓存穿透、缓存雪崩、缓存击穿

缓存穿透：高并发下查询key不存在的数据

解决方案：

1. 对查询结果为空的key进行缓存
2. 使用布隆过滤器

缓存雪崩：大量缓存同一时间失效

解决方案：

1. 不同key设置不同的有效期
2. 设置二级缓存

缓存击穿：某些热点数据在过期时间点突然大量的并发请求

解决方案：

1. 分布式锁



